### 设计模式

---

*2023.01.31 By* chamip *in Wuhan*

指在软件设计中，被反复使用的一种代码设计经验。**目的**是为了可重用代码，提高代码的可扩展性和可维护性。

[参考代码](https://github.com/chamip/DesignPattern)

#### 设计模式的类型：
- 创建型模式：关注点是如何创建对象，核心思想是把对象的创建和使用分离，使得两者能相互独立的变换。

  Factory Method、Abstract Factory、Builder、Prototype、Singleton

- 结构式模式：主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象提供了继承机制，但是结构性模式更多的是通过组合实现更灵活的功能。

​	Adaptor、Bridge、Composite、Decorator、Facade、Flyweight、Proxy

- 行为型模式：主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作完成一个整体任务。

​	Chain of Reposibility、Command、Iterator、Mediator、Memento、Observer、State、Strategy、Template Method、Visitor、Interpreter



#### 设计模式六大原则

##### 开闭原则
对扩展开放，对修改关闭。意思是增加新功能时，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。
##### 里氏代换原则
是一种面向对象的设计原则，就是如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该可以运行。

##### 依赖倒转原则

针对接口编程，依赖于抽象而不依赖于具体。

##### 接口隔离原则

使用多个隔离的接口，比使用单个接口要好。降低依赖，降低耦合。

##### 迪米特法则（最少知道原则）

一个实体应尽量少的和其他实体发生相互作用，使得系统功能模块相互独立。

##### 合成复用原则

尽量使用组合/聚合的方式，而不是继承。



#### 23种设计模式

##### 工厂模式

凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂模式创建。

- 普通工厂模式


就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。

- 多个工厂方法模式


普通工厂模式种如果传递的参数出错，无法创建对象。多个工厂方法模式就是在工厂类中提供多个工厂方法，分别创建对象。

- 静态工厂方法模式

在多个工厂方法模式的基础上，将工厂方法设置为静态，不需要创建工厂实力对象，直接调用。

##### 抽象工厂模式

工厂模式的问题是，类的创建依赖于工厂类，如果新增类的话就要对工厂类进行修改，违背开闭原则。抽象工厂模式就是创建多个工厂类，需要新增类的时候直接直接增加工厂类就行，不必修改之前的代码，扩展性好。

##### 单例模式

保证只有一个实例存在。好处是，避免类频繁创建对象，造成较大开销；省去new操作符，降低内存的使用频率。

##### 生成器模式

工厂模式是创建单个类，生成器模式就是将各种产品集中起来管理，用来创建复合对象。

##### 原型模式

将一个对象作为原型，对其进行克隆、复制，长生一个和原对象类似的新对象。

---

##### 适配器模式

是结构型模式下各种模式的起源。

将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要有三类：类的适配器模式、对象的适配器模式、接口的适配器模式。

##### 装饰器模式

给一个对象增加一些新的功能，而且是动态的（继承是静态的），要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。

##### 代理模式

多出来一个代理类，替原对象进行一些操作。

##### 外观模式

解决类与类之间的依赖关系，将类与类的关系放进一个Facade类，降低类类之间的耦合。

##### 桥接模式

把抽象部分和实现部分分开，使他们可以各自独立的变化。

##### 组合模式

在处理类似树形结构的问题时比较方便。

##### 享元模式

实现对象的共享，即共享池，减少内存开销。比如，当一个客户端请求时，工厂需要检查当前对象池是否有符合条件的对象，如果有，就返回已经有的对象，否则就创建一个对象。

---

##### 策略模式

定义一系列算法，并将每个算法封装起来，他们可以互相替换，算法的变化不会影响使用算法的客户。做法是，可以设计一个接口，为一系列实现提供统一的方法，多个实现类实现该接口，然后可以设计一个抽象类提供辅助函数。

##### 模版方法模式

一个抽象类中，有一个主方法，还有抽象方法、实际方法；定义一个继承类，重写抽象方法，通过调用抽象类，实现对子类的调用。

- 通过父类和子类的关系进行实现：策略模式和模版方法模式

##### 观察者模式

当一个对象变化时，其他依赖该对象的对象都会随着变化。

##### 迭代子模式

顺序访问聚集中的对象。

##### 责任链模式

有多个对象，没个对象持有对下一个对象的引用，形成一条链，请求在这条链上传递，直到某一处对象决定处理该请求。

##### 命令模式

调用者->命令->被调用者

- 两个类之间：观察者模式、迭代子模式、责任链模式、命令模式

##### 备忘录模式

保存一个对象的某个状态，以便在适当的时候恢复对象。

##### 状态模式

当对象的状态改变时，同时改变其行为。

- 类的状态：备忘录模式、状态模式

##### 访问者模式

分离对象的数据结构和行为。适用于数据结构相对稳定算法又易变化的系统。

##### 中介者模式

也是降低类之间的耦合。使用Mediaor类，关联的类之间的关系及调度都交给Mediator。

##### 解释器模式

一般用在OOP开发的编译器的开发中。

- 通过中间类：访问者模式、中介者模式、解释器模式
